const postcss = require('postcss');
const syntax = require('postcss-scss');
const { templates, types, regexDictionary } = require('../../kss/builder/parser/constants');
const sass = require('node-sass');
const fs = require('fs');
const path = require('path');

const outputDir =  './src/sass/tmp',
	disclaimer = `/* This file is generated by ./build/grunt/parser.js. All changes to this file will be eaten.*/\n`;

templates.forEach(function (template) {
	const sourceFile = fs.readFileSync(template.source, {encoding: 'utf8'});
	postcss()
		.process(sourceFile, {syntax: syntax})
		.then(function (result) {
			const nodes = result.root.nodes;
			const html = parseCss(template, nodes);

			try {
				fs.mkdirSync(outputDir);
			} catch (e) {
			}
			fs.writeFileSync(makeOutputAddress(template.name), disclaimer + html.join('\n'));

		}).catch(function (e) { console.log(e) });
});

function makeOutputAddress(name) {
	return outputDir + '/_' + name.toLowerCase() + '.scss';
}

function parseCss(template, nodes) {
	const sections = [],
		renderType = template.isGrid ? 'ColorTokens' : 'Tokens',
		variables = {};

	let majorNumber = 100,
		sectionCounter = 0,
		hasExample = false,
		shouldIgnore = false;

	nodes.forEach(function (node) {
		if (isComment(node)) {
			if (shouldIgnore || node.text === 'TokenParserIgnore') {
				shouldIgnore = node.text === 'TokenParserEndIgnore';
			} else {
				// Add the styleguide if the previous node was an inline comment/variable declaration
				const isNewHeader = node.prev() !== null && (node.prev().type === 'decl' || node.prev().source.start.column > 1);

				if (isNewHeader) {
					const styleGuide = template.isSubsection
						? `${template.name}.${majorNumber}.${sectionCounter}`
						: `${template.name}.${sectionCounter + majorNumber}`;

					if (!hasExample) {
						sections.push(`//`,`// NoExample: true`);
					}

					sections.push(`//`,`// Styleguide: ${styleGuide}`, ``);
					sectionCounter += 1;
					hasExample = false;
				}
				sections.push(`// ${node.text}`.trim());
			}

		} else if (!shouldIgnore && node.type === 'decl') {
			if (isComment(node.prev())) {
				sections.push(`// ${renderType}:`);
			}

			// replace any variable references with the value
			let value = node.value.replace(regexDictionary.sassVariables, function (varName) {
				return variables[varName];
			});

			// compile any special sass functions
			if (regexDictionary.rgbaWithHex.test(value) || regexDictionary.mixedFunction.test(value)) {
				value = compileSass(value);
			}

			variables[node.prop] = value;
			const variable = translateVariable(node.prop, value);

			if (variable.hasExample) {
				hasExample = true;
			}
			sections.push(`// ${variable.value}`);
		}
	});

	const styleGuide = template.isSubsection ? `${template.name}.${majorNumber}.${sectionCounter}` : `${template.name}.${sectionCounter + majorNumber}`;
	if (!hasExample) {
		sections.push(`//`,`// NoExample: true`);
	}
	sections.push(`//`,`// Styleguide: ${styleGuide}`, ``);
	return sections;
}

function isComment(node) {
	return node.type === 'comment' && node.source.start.column < 2 && !!node.raws.inline;
}

function compileSass(expression) {
	const result = sass.renderSync({
		data: '.abc { border: ' + expression + ' }',
		outputStyle: 'compressed',
		sourceMap: false
	});
	return result.css.toString().match(regexDictionary.compiledSass)[1];
}

function translateVariable(name, value) {
	const type = getType(name, value);

	if (regexDictionary.rem.test(value)) {
		value = (value.match(regexDictionary.rem)[1] * 16) + 'px';
	}
	return {
		value: `${name} : ${value} : ${type}`,
		hasExample: !!type
	};
}

function getType(name, value) {
	let type = '';

	if (regexDictionary.colorHash.test(value) || regexDictionary.colorRgba.test(value)) {
		type = types.color;

	} else if (regexDictionary.border.test(value)) {
		type = types.border;

	} else if (regexDictionary.shadow.test(value)) {
		type = types.shadow;

	} else if (regexDictionary.lineHeight.test(name)) {
		type = types.lineHeight;

	} else if (regexDictionary.fontWeight.test(name)) {
		type = types.fontWeight;

	} else if (regexDictionary.size.test(value)) {

		if (regexDictionary.font.test(name)) {
			type = types.fontSize;

		} else if(regexDictionary.spacing.test(name)) {
			type = types.spacing;
		}

	}

	return type;
}
