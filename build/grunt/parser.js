const postcss = require('postcss');
const syntax = require('postcss-scss');
const sass = require('node-sass');
const fs = require('fs');
const path = require('path');

const disclaimer = `/* This file is generated by ./build/grunt/parser.js. All changes to this file will be eaten.*/\n`;
const templates = {
	'./src/sass/settings/_colors.scss' :
	{
		name: 'Colors',
		outputDir: './src/sass/tmp',
		outputFile: './src/sass/tmp/_colors.scss',
	}
};

const regexDictionary = {
	border: /^[-]?\d+px\s[\w]\s*/,
	colorHash: /^#[\w\d]+$/,
	colorRgba: /^rgba\(.*\)$/,
	isInverted: /inverted/,
	mixedFunction: /mix\(.*\)/,
	repeatedCharacter: /(.)\1{4,}/,
	rgba: /rgba\(.*\)/,
	rgbaWithHex: /rgba\(#([a-f\d]){3,6}/,
	sassVariables: /(\$[^\s,;)]*)/g,
	shadow: /^([-]?[0-9px]+\s){4}(rgba(.*)$|#(.*)$)/,
	size: /^[-]?\d+px$/
};

const sources = Object.keys(templates);
sources.forEach(function (source) {
	const sourceFile = fs.readFileSync(source, {encoding: 'utf8'});
	const template = templates[source];
	postcss()
		.process(sourceFile, {syntax: syntax})
		.then(function (result) {
			const nodes = result.root.nodes;
			const html = parseCss(template.name, nodes);

			try {
				fs.mkdirSync(template.outputDir);
			}	catch (e){};
			fs.writeFileSync(template.outputFile, disclaimer + html.join('\n'));

		}).catch(function (e) {
			console.log(e)
	});
});

function parseCss(sourceName, nodes) {
	const result = [],
				variables = {};

	let decls = [],
			sectionCounter = 1;

	nodes.forEach(function (node) {
		if (node.type === 'comment' && node.source.start.column < 2 && !node.text.match(regexDictionary.repeatedCharacter) && !!node.raws.inline ) {
			const isHeader = node.prev() == null || node.prev().type !== 'comment' || node.prev().raws.inline;

			if (isHeader && decls.length !== 0) {
				result.push(renderSection(decls.join(''),  `${sourceName}.${sectionCounter}`));
				decls = [];
				sectionCounter += 1;
			}
			result.push(`// ${node.text}`.trim());
		}

		if (node.type === 'decl') {
			let value = node.value.replace(regexDictionary.sassVariables, function (varName) {
				return variables[varName];
			});

			if (regexDictionary.rgbaWithHex.test(value) || regexDictionary.mixedFunction.test(value)) {
				value = compileSass(value);
			}

			variables[node.prop] = value;
			decls.push(renderRow(node.prop, value));
		}
	});

	if(decls.length !== 0) {
		result.push(renderSection(decls.join(''), `${sourceName}.${sectionCounter}`));
	}
	return result;
}

function compileSass(expression) {
	var result = sass.renderSync({
		data: '.abc { border: ' + expression + ' }',
		outputStyle: 'compressed',
		sourceMap: false
	});
	return result.css.toString().match(regexDictionary.rgba)[0];
}

function renderRow(name, value) {
	let cellClass = '',
		valueClass = '',
		html = '';

	if(regexDictionary.isInverted.test(name)) {
		cellClass =	`xuidocs-table-inverted-cell`;
		valueClass = `xuidocs-inverted-text`;
	}

	if (regexDictionary.colorHash.test(value) || regexDictionary.colorRgba.test(value)) {
		html = `<div class="xuidocs-box" style="background-color:${value};"></div>`;

	} else if (regexDictionary.size.test(value)) {
		//TODO Implement Sizes in the future

	} else if (regexDictionary.border.test(value)) {
		html = `<div style="border:${value};"></div>`;

	} else if (regexDictionary.shadow.test(value)) {
		html = `<div class="xuidocs-box" style="box-shadow:${value};"></div>`;
	}

	return `<tr class="xuidocs-table--row"><td class="xuidocs-table--cell"><code class="xuidocs-text">${name}</code></td>` +
	 `<td class="xuidocs-table--cell ${cellClass}">` +
	 	`${html}` +
	 `<code class="xuidocs-text ${valueClass}">${value}</code> ` +
	 	`</td></tr>`;
}

function renderSection(bodyHtml, styleGuide) {
	return `//
// Markup: 
// <table class="xuidocs-table">
// <thead>
//	<td class="xuidocs-table--cell xuidocs-table--header">
//	<span class="xui-section-title">Token</span>
// 	</td>
// 	<td class="xuidocs-table--cell xuidocs-table--header">
// 		<span class="xui-section-title">Example</span>
// 	</td>
// 	</thead>
// 	<tbody>
// 		${bodyHtml}
// 	</tbody>
// </table>
// 
// Styleguide: ${styleGuide}
`;
}
