const postcss = require('postcss');
const syntax = require('postcss-scss');
const sass = require('node-sass');
const fs = require('fs');
const path = require('path');

const disclaimer = `/* This file is generated by ./build/grunt/parser.js. All changes to this file will be eaten.*/\n`;
const outputDir = './src/sass/tmp';

const templates = [
	{
		name: 'Colors',
		source: './src/sass/settings/_colors.scss'
	},
	{
		name: 'Typography',
		source: './src/sass/settings/_typography.scss',
		isSubsection: true
	}
];

const regexDictionary = {
	border: /^[-]?\d+px\s[\w]\s*/,
	colorHash: /^#[\w\d]+$/,
	colorRgba: /^rgba\(.*\)$/,
	isInverted: /inverted/,
	mixedFunction: /mix\(.*\)/,
	repeatedCharacter: /(.)\1{4,}/,
	rgba: /rgba\(.*\)/,
	rgbaWithHex: /rgba\(#([a-f\d]){3,6}/,
	sassVariables: /(\$[^\s,;)]*)/g,
	shadow: /^([-]?[0-9px]+\s){4}(rgba(.*)$|#(.*)$)/,
	size: /^[-]?\d+px$/
};

templates.forEach(function (template) {
	const sourceFile = fs.readFileSync(template.source, {encoding: 'utf8'});
	postcss()
		.process(sourceFile, {syntax: syntax})
		.then(function (result) {
			const nodes = result.root.nodes;
			const html = parseCss(template, nodes);

			try {
				fs.mkdirSync(outputDir);
			}	catch (e){};
			fs.writeFileSync(makeOutputAddress(template.name), disclaimer + html.join('\n'));

		}).catch(function (e) {
			console.log(e)
	});
});

function makeOutputAddress(name) {
	return outputDir + '/_' + name.toLowerCase() + '.scss';
}

function parseCss(template, nodes) {
	const result = [],
				variables = {};

	let decls = [],
			majorNumber = 100,
			sectionCounter = 0;

	nodes.forEach(function (node) {
		if (node.type === 'comment' && node.source.start.column < 2 && !node.text.match(regexDictionary.repeatedCharacter) && !!node.raws.inline ) {
			const isHeader = node.prev() == null || node.prev().type !== 'comment' || node.prev().raws.inline;
			
			if (isHeader && decls.length !== 0) {
				const styleGuide = template.isSubsection?`${template.name}.${majorNumber}.${sectionCounter}` :  `${template.name}.${sectionCounter + majorNumber}`;
				result.push(renderSection(decls.join(''),  styleGuide));
				decls = [];
				sectionCounter += 1;
			}
			result.push(`// ${node.text}`.trim());
		}

		if (node.type === 'decl') {
			let value = node.value.replace(regexDictionary.sassVariables, function (varName) {
				return variables[varName];
			});

			if (regexDictionary.rgbaWithHex.test(value) || regexDictionary.mixedFunction.test(value)) {
				value = compileSass(value);
			}

			variables[node.prop] = value;
			decls.push(renderRow(node.prop, value, template.isSubsection));
		}
	});

	if(decls.length !== 0) {
		const styleGuide = template.isSubsection?`${template.name}.${majorNumber}.${sectionCounter}` :  `${template.name}.${sectionCounter + majorNumber}`;
		result.push(renderSection(decls.join(''), styleGuide));
	}
	return result;
}

function compileSass(expression) {
	var result = sass.renderSync({
		data: '.abc { border: ' + expression + ' }',
		outputStyle: 'compressed',
		sourceMap: false
	});
	return result.css.toString().match(regexDictionary.rgba)[0];
}

function renderRow(name, value, isSubsection=false) {
	let cellClass = '',
		valueClass = '',
		html = '';

	if(!isSubsection) {
		if(regexDictionary.isInverted.test(name)) {
			cellClass =	`xuidocs-table-inverted-cell`;
			valueClass = `xuidocs-inverted-text`;
		}

		if (regexDictionary.colorHash.test(value) || regexDictionary.colorRgba.test(value)) {
			html = `<div class="xuidocs-box" style="background-color:${value};"></div>`;

		} else if (regexDictionary.size.test(value)) {
			//TODO Implement Sizes in the future

		} else if (regexDictionary.border.test(value)) {
			html = `<div style="border:${value};"></div>`;

		} else if (regexDictionary.shadow.test(value)) {
			html = `<div class="xuidocs-box" style="box-shadow:${value};"></div>`;
		}
	}

	return `<tr class="xuidocs-table--row"><td class="xuidocs-table--cell"><code class="xuidocs-text">${name}</code></td>` +
	 `<td class="xuidocs-table--cell ${cellClass}">` +
	 	`${html}` +
	 `<code class="xuidocs-text ${valueClass}">${value}</code> ` +
	 	`</td></tr>`;
}

function renderSection(bodyHtml, styleGuide) {
	return `//
// Markup: 
// <table class="xuidocs-table">
// <thead>
//	<td class="xuidocs-table--cell xuidocs-table--header">
//	<span class="xui-section-title">Token</span>
// 	</td>
// 	<td class="xuidocs-table--cell xuidocs-table--header">
// 		<span class="xui-section-title">Example</span>
// 	</td>
// 	</thead>
// 	<tbody>
// 		${bodyHtml}
// 	</tbody>
// </table>
// 
// Styleguide: ${styleGuide}
`;
}
