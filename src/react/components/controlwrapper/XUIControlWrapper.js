import React, { PureComponent } from 'react';
import PropTypes from 'prop-types';
import cn from 'classnames';

import { ns } from '../helpers/xuiClassNamespace';
import LabelElement from './private/LabelElement';
import MessageElement from './private/MessageElement';

import '../../../sass/7-components/_forms.layout.scss';

/* eslint-disable max-len */
/**
 * @public
 * Get the collection of aria attributes to be applied to the control.
 * Independent of the component, for timing purposes.
 * @param {Object} ids - generated ids from ./helpers, including label and message ids
 * @param {Object} props - props of the parent control component
 * @returns {{aria-invalid: boolean, aria-label: string, aria-labelledby: string, aria-describedby: string}}
 */
/* eslint-enable max-len */
export function getAriaAttributes(ids, props) {
	const {
		labelText,
		isLabelHidden,
		validationMessage,
		hintMessage,
		labelId,
		isInvalid,
	} = props;

	// props.placeholder pulls possible backup label from a textInput.
	// props.buttonContent pulls possible backup label from a selectBox.
	const fallBackLabel = props.placeholder || props.buttonContent;

	// Create a "labelledby" attribute if there is label content, or if the user has provided an id.
	const ariaLabelledBy = (labelText != null && !isLabelHidden && ids.label)
		|| (!labelText && labelId)
		|| undefined;

	// Add hidden label (or fallBackLabel as label if that's all we've got)
	const ariaLabel = (isLabelHidden && labelText)
		|| (!ariaLabelledBy && fallBackLabel)
		|| undefined;

	// Create a "describedby" attribute if there is a hint or validation message to display.
	const ariaDescribedBy = ((hintMessage || (validationMessage && isInvalid)) && ids.message)
		|| undefined;

	return {
		'aria-invalid': isInvalid,
		'aria-label': ariaLabel,
		'aria-labelledby': ariaLabelledBy,
		'aria-describedby': ariaDescribedBy,
	};
}

export default class XUIControlWrapper extends PureComponent {
	render() {
		const {
			children,
			fieldClassName,
			onKeyDown,
			isFieldLayout,
			onClick,
			isGroup,
			labelClassName,
			labelText,
			isLabelHidden,
			qaHook,
			wrapperIds,
			isInvalid,
			validationMessage,
			hintMessage,
		} = this.props;

		const rootClasses = cn(
			fieldClassName,
			isFieldLayout && `${ns}-field-layout`,
		);

		const TagType = isGroup ? 'div' : 'label';

		return (
			<TagType className={rootClasses} onKeyDown={onKeyDown} onClick={onClick} role="presentation">
				<LabelElement
					label={labelText}
					{...{
						labelClassName,
						isLabelHidden,
						qaHook,
						wrapperIds,
					}}
				/>
				{children}
				<MessageElement {...{
					isInvalid,
					validationMessage,
					hintMessage,
					qaHook,
					wrapperIds,
				}}
				/>
			</TagType>
		);
	}
}

XUIControlWrapper.propTypes = {
	qaHook: PropTypes.string,
	children: PropTypes.node,
	/** Function to call on keydown inside the control */
	onKeyDown: PropTypes.func,
	/** Function to call on click inside the control */
	onClick: PropTypes.func,
	/** Label to show above the input */
	labelText: PropTypes.string,
	/** Whether the current input value is invalid */
	isInvalid: PropTypes.bool,
	/** Validation message to show under the input if `isInvalid` is true */
	validationMessage: PropTypes.string,
	/** Hint message to show under the input */
	hintMessage: PropTypes.string,
	/** Whether to use the field layout classes */
	isFieldLayout: PropTypes.bool,
	/** Class names to be added to the field wrapper element */
	fieldClassName: PropTypes.string,
	/** Class names to add to the label */
	labelClassName: PropTypes.string,
	/** Should label be applied as an aria-label, rather than being visibly displayed. */
	isLabelHidden: PropTypes.bool,
	/** IDs generated by generateIds and passed in from the parent component */
	wrapperIds: PropTypes.shape({
		label: PropTypes.string,
		message: PropTypes.string,
	}).isRequired,
	/** Whether this will be used to wrap multple controls with their own labels */
	isGroup: PropTypes.bool,
};

XUIControlWrapper.defaultProps = {
	isGroup: false,
};
