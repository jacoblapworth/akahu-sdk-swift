import React from 'react';
import PropTypes from 'prop-types';
import cn from 'classnames';

import { ns } from '../helpers/xuiClassNamespace';
import LabelElement from './private/LabelElement';
import MessageElement from './private/MessageElement';
import GroupContext from '../../contexts/GroupContext';

const XUIControlWrapper = React.forwardRef(
  (
    {
      characterCounter,
      children,
      fieldClassName,
      hintMessage,
      isFieldLayout,
      isGroup,
      isInvalid,
      isLabelHidden,
      label,
      labelClassName,
      labelRef,
      onClick,
      onKeyDown,
      qaHook,
      validationMessage,
      wrapperIds,
      wrapperProps,
    },
    ref,
  ) => {
    const rootClasses = cn(fieldClassName, isFieldLayout && `${ns}-field-layout`);
    const messageEle =
      ((hintMessage || validationMessage) && (
        <MessageElement
          {...{
            isInvalid,
            validationMessage,
            hintMessage,
            qaHook,
            wrapperIds,
          }}
        />
      )) ||
      undefined;

    return (
      /* eslint-disable jsx-a11y/no-static-element-interactions */
      <GroupContext.Consumer>
        {({ useFlatElementStructure }) => {
          const labelEle = (
            <LabelElement
              isGroup={isGroup}
              {...{
                characterCounter,
                label,
                labelClassName,
                labelRef,
                isLabelHidden,
                qaHook,
                useFlatElementStructure,
                wrapperIds,
              }}
            />
          );

          // For single controls: render label, message, and input as siblings wrapped in a div.
          // For grouped controls: wrap the input only, then render all three elements as
          // top-level siblings (for grid layout).
          return (
            <>
              {useFlatElementStructure && labelEle}
              <div
                className={cn(
                  rootClasses,
                  messageEle && useFlatElementStructure && `${ns}-has-message`,
                )}
                onClick={onClick}
                onKeyDown={onKeyDown}
                ref={ref}
                role={(onClick || onKeyDown) && 'presentation'}
                {...wrapperProps}
              >
                {!useFlatElementStructure && labelEle}
                {children}
                {!useFlatElementStructure && messageEle}
              </div>
              {useFlatElementStructure && messageEle}
            </>
          );
        }}
      </GroupContext.Consumer>
      /* eslint-enable */
    );
  },
);

export default XUIControlWrapper;

XUIControlWrapper.propTypes = {
  /** Character counter props */
  characterCounter: PropTypes.object,

  children: PropTypes.node,

  /** Class names to be added to the field wrapper element */
  fieldClassName: PropTypes.string,

  /** Hint message to show under the input */
  hintMessage: PropTypes.node,

  /** Whether to use the field layout classes */
  isFieldLayout: PropTypes.bool,

  /**
   * Whether this will be used to wrap multiple controls with their own labels
   */
  isGroup: PropTypes.bool,

  /** Whether the current input value is invalid */
  isInvalid: PropTypes.bool,

  /** Should label be applied as an aria-label, rather than being visibly displayed. */
  isLabelHidden(props, propName) {
    if (props[propName] && props.label && typeof props.label[0] !== 'string') {
      return new Error('To include a hidden label ensure the label is plain text.');
    }
    return null;
  },

  /** Label to show above the input */
  label: PropTypes.node,

  /** Class names to add to the label */
  labelClassName: PropTypes.string,

  /** Sets a ref for the label element */
  labelRef: PropTypes.oneOfType([PropTypes.func, PropTypes.object]),

  /** Function to call on click inside the control */
  onClick: PropTypes.func,

  /** Function to call on keydown inside the control */
  onKeyDown: PropTypes.func,

  qaHook: PropTypes.string,

  /** Validation message to show under the input if `isInvalid` is true */
  validationMessage: PropTypes.node,

  /** IDs generated by generateIds and passed in from the parent component */
  wrapperIds: PropTypes.shape({
    control: PropTypes.string,
    label: PropTypes.string,
    message: PropTypes.string,
  }).isRequired,
  /** Stuff to spread on the div wrapping the control itself */
  wrapperProps: PropTypes.object,
};

XUIControlWrapper.defaultProps = {
  isGroup: false,
};
