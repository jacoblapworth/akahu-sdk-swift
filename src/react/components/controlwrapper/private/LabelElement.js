import React, { PureComponent } from 'react';
import PropTypes from 'prop-types';
import cn from 'classnames';

import { ns } from '../../helpers/xuiClassNamespace';
import shouldRender from '../../helpers/shouldRender';
import CharacterCounterElement from './CharacterCounterElement';

export default class LabelElement extends PureComponent {
  render() {
    const {
      characterCounter,
      labelClassName,
      label,
      isLabelHidden,
      qaHook,
      wrapperIds,
      isInline,
      isGroup,
      labelRef,
    } = this.props;
    const labelClasses = isInline
      ? labelClassName
      : cn(labelClassName, `${ns}-text-label`, `${ns}-fieldlabel-layout`);

    // If label is inline with control or for a group of controls, we'll target
    // it with labelledby, rather than connecting it to the control with htmlFor.
    const isLabelTargetedByControl = isInline || isGroup;
    const TagType = isLabelTargetedByControl ? 'span' : 'label';

    const labelElement = shouldRender(label) && !isLabelHidden && (
      <TagType
        className={labelClasses}
        data-automationid={qaHook && `${qaHook}--label`}
        htmlFor={isLabelTargetedByControl ? undefined : wrapperIds.control}
        id={(isLabelTargetedByControl && wrapperIds.label) || undefined}
        ref={labelRef}
      >
        {label}
      </TagType>
    );

    const wrapperWithCharacterCounter = characterCounter?.maxCharCount ? (
      <div className={`${ns}-controlwrapper-header-row`}>
        {labelElement}
        <CharacterCounterElement
          {...{
            characterCounter,
            qaHook,
          }}
        />
      </div>
    ) : (
      labelElement
    );

    return wrapperWithCharacterCounter || null;
  }
}

LabelElement.propTypes = {
  /** Character counter props */
  characterCounter: PropTypes.object,
  /** Whether this will be used to wrap multple controls with their own labels */
  isGroup: PropTypes.bool,
  /** Whether this label will be used inline with the control, or outside of it */
  isInline: PropTypes.bool,
  /** Should label be applied as an aria-label, rather than being visibly displayed. */
  isLabelHidden: PropTypes.bool,
  /** Label to show near the input. Validated on the wrapper. */
  label: PropTypes.node,
  /** Class names to add to the label */
  labelClassName: PropTypes.string,
  /** Sets a ref for the label element */
  labelRef: PropTypes.oneOfType([PropTypes.func, PropTypes.object]),
  qaHook: PropTypes.string,
  /** IDs generated by generateIds and passed in from the parent component of the wrapper */
  wrapperIds: PropTypes.shape({
    control: PropTypes.string,
    label: PropTypes.string,
    message: PropTypes.string,
  }).isRequired,
};
