import React, { PureComponent } from 'react';
import PropTypes from 'prop-types';
import cn from 'classnames';

import { ns } from '../../helpers/xuiClassNamespace';

export default class LabelElement extends PureComponent {
  render() {
    const {
      labelClassName,
      label,
      isLabelHidden,
      qaHook,
      wrapperIds,
      isInline,
      isGroup,
    } = this.props;
    const labelClasses = isInline
      ? labelClassName
      : cn(labelClassName, `${ns}-text-label`, `${ns}-fieldlabel-layout`);

    // If label is inline with control or for a group of controls, we'll target
    // it with labelledby, rather than connecting it to the control with htmlFor.
    const isLabelTargetedByControl = isInline || isGroup;
    const TagType = isLabelTargetedByControl ? 'span' : 'label';

    const labelElement = label != null && !isLabelHidden && (
      <TagType
        className={labelClasses}
        data-automationid={qaHook && `${qaHook}--label`}
        htmlFor={isLabelTargetedByControl ? undefined : wrapperIds.control}
        id={(isLabelTargetedByControl && wrapperIds.label) || undefined}
      >
        {label}
      </TagType>
    );
    return labelElement || null;
  }
}

LabelElement.propTypes = {
  qaHook: PropTypes.string,
  /** Label to show near the input. Validated on the wrapper. */
  label: PropTypes.node,
  /** Class names to add to the label */
  labelClassName: PropTypes.string,
  /** Should label be applied as an aria-label, rather than being visibly displayed. */
  isLabelHidden: PropTypes.bool,
  /** IDs generated by generateIds and passed in from the parent component of the wrapper */
  wrapperIds: PropTypes.shape({
    label: PropTypes.string,
    control: PropTypes.string,
    message: PropTypes.string,
  }).isRequired,
  /** Whether this label will be used inline with the control, or outside of it */
  isInline: PropTypes.bool,
  /** Whether this will be used to wrap multple controls with their own labels */
  isGroup: PropTypes.bool,
};
